{"componentChunkName":"component---src-pages-api-js","path":"/api/@prestojs/rest/Endpoint.html","result":{"data":{"mdx":null,"typeDocsJson":{"kindString":"Class","name":"Endpoint","id":"2177","comment":{"shortText":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Describe an REST API endpoint that can then be executed.\"));\n}\n;\nMDXContent.isMDXComponent = true;"},"text":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Accepts a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UrlPattern\"), \" and optionally a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"decodeBody\"), \" function which decodes the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Response\"), \" body as returned by\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"fetch\"), \" and a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"transformResponseBody\"), \" function that can transform the decoded body. The default \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"decodeBody\"), \" handles\\ndecoding the data based on content type and is suitable for endpoints that return JSON or text with the appropriate\\ncontent types. If you just wish to do something with the decoded data (eg. the JSON data) use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"transformResponseBody\"), \".\"), mdx(\"p\", null, \"In addition you can pass all options accepted by \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"fetch\"), \" and these will be used as defaults to any call to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"execute\"), \"\\nor \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"prepare\"), \".\"), mdx(\"p\", null, \"Usage:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const userList = new Action(new UrlPattern('/api/users/'));\\nconst users = await userList.execute();\\n\")), mdx(\"p\", null, \"You can pass \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"urlArgs\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"query\"), \" to resolve the URL:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const userDetail = new Action(new UrlPattern('/api/user/:id/'));\\n// Resolves to /api/user/1/?showAddresses=true\\nconst user = await userDetail.execute({ urlArgs: { id: 1 }, query: 'showAddresses': true });\\n\")), mdx(\"p\", null, \"You can also pass through any \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"fetch\"), \" options to both the constructor and calls to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"execute\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"prepare\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"// Always pass through Content-Type header to all calls to userDetail\\nconst userDetail = new Action(new UrlPattern('/api/user/:id/'), {\\n    'Content-Type': 'application/json'\\n});\\n// Set other fetch options at execution time\\nuserDetail.execute({ urlArgs: { id: 1 }, method: 'PATCH', body: JSON.stringify({ name: 'Dave' }) });\\n\")), mdx(\"p\", null, \"Often you have some global options you want to apply everywhere. This can be set on \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Endpoint\"), \"\\ndirectly:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"// Set default options to pass through to the request init option of `fetch`\\nEndpoint.defaultConfig.requestInit = {\\n  headers: {\\n    'X-CSRFToken': getCsrfToken(),\\n  },\\n};\\n\\n// All actions will now use the default headers specified\\nuserDetail.execute({ urlArgs: { id: 1 } });\\n\")), mdx(\"p\", null, \"You can also \\\"prepare\\\" an action for execution by calling the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"prepare\"), \" method. Each call to prepare will\\nreturn the same object (ie. it passes strict equality checks) given the same parameters. This is useful when\\nyou need to have a stable cache key for an action. For example you may have a React hook that executes\\nyour action when things change:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"import useSWR from 'swr';\\n\\n...\\n\\n// prepare the action and pass it to useSWR. useSWR will then call the second parameter (the \\\"fetcher\\\")\\n// which executes the prepared action.\\nconst { data } = useSWR([action.prepare()], (preparedAction) => preparedAction.execute());\\n\")), mdx(\"p\", null, \"You can wrap this up in a custom hook to make usage more ergonomic:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"import { useCallback } from 'react';\\nimport useSWR from 'swr';\\n\\n/**\\n* Wrapper around useSWR for use with `Endpoint`\\n* @param action Endpoint to execute. Can be null if not yet ready to execute\\n* @param args Any args to pass through to `prepare`\\n* @return Object Same values as returned by useSWR with the addition of `execute` which\\n* can be used to execute the action directly, optionally with new arguments.\\n*\\nexport default function useEndpoint(action, args) {\\n  const preparedAction = action ? action.prepare(args) : null;\\n  const execute = useCallback(init => preparedAction.execute(init), [preparedAction]);\\n  return {\\n    execute,\\n    ...useSWR(preparedAction && [preparedAction], act => act.execute()),\\n  };\\n}\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;"}},"groups":[{"title":"Constructors","children":[2192]},{"title":"Properties","children":[2187,2191,2182,2186,2181]},{"title":"Methods","children":[2215,2206]},{"title":"Object literals","children":[2178]}],"slug":"/api/@prestojs/rest/Endpoint.html","packageName":"rest","signatures":null,"childNodes":[{"id":2192,"flags":{"isPrivate":null},"signatures":[{"name":"new Endpoint","comment":null,"parameters":[{"id":2194,"name":"urlPattern","comment":null},{"id":2195,"name":"__namedParameters","comment":null}],"inheritedFrom":null}]},{"id":2187,"flags":{"isPrivate":null},"signatures":null},{"id":2191,"flags":{"isPrivate":null},"signatures":null},{"id":2182,"flags":{"isPrivate":null},"signatures":null},{"id":2186,"flags":{"isPrivate":null},"signatures":null},{"id":2181,"flags":{"isPrivate":null},"signatures":null},{"id":2215,"flags":{"isPrivate":null},"signatures":[{"name":"execute","comment":{"shortText":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Triggers the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"fetch\"), \" call for an action\"));\n}\n;\nMDXContent.isMDXComponent = true;"},"text":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"This can be called directly or indirectly via \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"prepare\"), \".\"), mdx(\"p\", null, \"If the fetch call itself fails (eg. a network error) a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"RequestError\"), \" will be thrown.\"), mdx(\"p\", null, \"If the response is a non-2XX response an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ApiError\"), \" will be thrown.\"), mdx(\"p\", null, \"If the call is successful the body will be decoded using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"decodeBody\"), \". The default implementation\\nwill decode JSON to an object or return text based on the content type. If the content type is\\nnot JSON or text the raw \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Response\"), \" will be returned.\"), mdx(\"p\", null, \"You can transform the decoded body with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"transformResponseBody\"), \". This is useful if you need to do something\\nwith the returned data. For example you could add it to a cache or create an instance of a class.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"// Via prepare\\nconst preparedAction = action.prepare({ urlArgs: { id: '1' }});\\npreparedAction.execute();\\n\\n// Directly\\naction.execute({ urlArgs: { id: '1' }});\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;"}},"parameters":[{"id":2217,"name":"__namedParameters","comment":null}],"inheritedFrom":null}]},{"id":2206,"flags":{"isPrivate":null},"signatures":[{"name":"prepare","comment":{"shortText":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Prepare an action for execution. Given the same parameters returns the same object. This is useful\\nwhen using libraries like \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useSWR\"), \" that accept a parameter that identifies a request and is used\\nfor caching but execution is handled by a separate function.\"));\n}\n;\nMDXContent.isMDXComponent = true;"},"text":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"For example to use with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useSWR\"), \" you can do:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const { data } = useSWR([action.prepare()], (preparedAction) => preparedAction.execute());\\n\")), mdx(\"p\", null, \"If you just want to call the action directly then you can bypass \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"prepare\"), \" and just call \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"execute\"), \"\\ndirectly.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"parameters":[{"id":2208,"name":"__namedParameters","comment":null}],"inheritedFrom":null}]},{"id":2178,"flags":{"isPrivate":null},"signatures":null}]}},"pageContext":{"id":"2177","slug":"/api/@prestojs/rest/Endpoint.html"}}}