{"expireTime":9007200833969727000,"key":"gatsby-plugin-mdx-entire-payload-18dc84df8476c642041aef8050730929-","val":{"mdast":{"type":"root","children":[{"type":"paragraph","children":[{"type":"text","value":"The key to the cache is the primary key for the record and the field names\nset on it. For example if you have a record that accepts id, name and email\nyou could have a record cached for id, for name, for email or any\ncombination of the 3 fields. This is to handle the common case of fetching\npartial data from a backend.","position":{"start":{"line":1,"column":1,"offset":0},"end":{"line":5,"column":29,"offset":320},"indent":[1,1,1,1]}}],"position":{"start":{"line":1,"column":1,"offset":0},"end":{"line":5,"column":29,"offset":320},"indent":[1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"The cache implementation will update any cache entries that are a subset\nof a new cache entry. eg. Caching a record with all the possible fields set\nwould result in all the existing partial field cache entries being updated\nto match the data on the full record for the fields it care about.","position":{"start":{"line":7,"column":1,"offset":322},"end":{"line":10,"column":67,"offset":612},"indent":[1,1,1]}}],"position":{"start":{"line":7,"column":1,"offset":322},"end":{"line":10,"column":67,"offset":612},"indent":[1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"Usage:","position":{"start":{"line":12,"column":1,"offset":614},"end":{"line":12,"column":7,"offset":620},"indent":[]}}],"position":{"start":{"line":12,"column":1,"offset":614},"end":{"line":12,"column":7,"offset":620},"indent":[]}},{"type":"code","lang":"js","meta":null,"value":"// Assume User is a ViewModel already defined\n\n// Add a record\nUser.cache.add(new User({ id: 1, name: 'John' }));\n\n// Retrieve a record\nconst record = User.cache.get(1, ['id', 'name']);\n\n// To update a record just add it again\nUser.cache.add(new User({ id: 1, name: 'Johnny' }));\n\n// Cache is per unique set of fields but a superset will update a subset\nUser.cache.add(new User({ id: 1, name: 'Johnny Smith', email: 'johnny@test.com' }));\nUser.cache.get(1, ['id', 'name']);\n// { id: 1, name: 'Johnny Smith' }\nUser.cache.get(1, ['id', 'name', 'email'])\n// { id: 1, name: 'Johnny Smith', email: 'johnny@test.com' }\n\n// Delete a specific cache for a subset of fields\nUser.cache.delete(1, ['id', 'name']);\nUser.cache.get(1, ['id', 'name']);\n// null\nUser.cache.get(1, ['id', 'name', 'email'])\n// { id: 1, name: 'Johnny Smith', email: 'johnny@test.com' }\n\n// Or all fields\nUser.cache.delete(1);\nUser.cache.get(1, ['id', 'name', 'email'])\n// null\n\n// You can add multiple values at a time\nUser.cache.addList([johnny, sam]);\n\n// You can listen to changes\nUser.cache.addListener(2, ['id', 'name'], (previous, next) => console.log(previous, 'change to', next));\nUser.cache.add(new User({ id: 2, name: 'Bob' }));\n// null changed to User({ id: 2, name: 'Bob' })\nUser.cache.add(new User({ id: 2, name: 'Bobby' }));\n// User({ id: 2, name: 'Bob' }) changed to User({ id: 2, name: 'Bobby' })\nUser.cache.delete(2)\n// User({ id: 2, name: 'Bobby' }) changed to null\n\n// You can listen to multiple changes. If you use this and addList then you only get one\n// call for each change that occurs within addList\nUser.cache.addListenerList(\n // Ids to listen for changes to\n [3, 4],\n // Only get updates for cached records with these field names\n ['id', 'name'],\n (previous, next) => console.log(previous, 'change to', next)\n);\nUser.cache.addList([new User({ id: 3, name: 'Jay' }), new User({ id: 4, name: 'Bee' })]);\n// [null, null] changed to [new User({ id: 3, name: 'Jay' }), new User({ id: 4, name: 'Bee' })]\nUser.cache.addList([new User({ id: 3, name: 'Jayz' }), new User({ id: 4, name: 'Beeb' })]);\n// [new User({ id: 3, name: 'Jay' }), new User({ id: 4, name: 'Bee' })] changed to [new User({ id: 3, name: 'Jayz' }), new User({ id: 4, name: 'Beeb' })]\nUser.cache.delete(3)\n// [new User({ id: 3, name: 'Jayz' }), new User({ id: 4, name: 'Beeb' })] changed to [null, new User({ id: 4, name: 'Beeb' })]","position":{"start":{"line":14,"column":1,"offset":622},"end":{"line":72,"column":4,"offset":3014},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"export","value":"export const _frontmatter = {}","position":{"start":{"line":75,"column":1,"offset":3017},"end":{"line":75,"column":31,"offset":3047},"indent":[]}}],"position":{"start":{"line":1,"column":1,"offset":0},"end":{"line":75,"column":31,"offset":3047}}},"scopeImports":["import React from 'react'"],"scopeIdentifiers":["React"],"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"The key to the cache is the primary key for the record and the field names\\nset on it. For example if you have a record that accepts id, name and email\\nyou could have a record cached for id, for name, for email or any\\ncombination of the 3 fields. This is to handle the common case of fetching\\npartial data from a backend.\"), mdx(\"p\", null, \"The cache implementation will update any cache entries that are a subset\\nof a new cache entry. eg. Caching a record with all the possible fields set\\nwould result in all the existing partial field cache entries being updated\\nto match the data on the full record for the fields it care about.\"), mdx(\"p\", null, \"Usage:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"// Assume User is a ViewModel already defined\\n\\n// Add a record\\nUser.cache.add(new User({ id: 1, name: 'John' }));\\n\\n// Retrieve a record\\nconst record = User.cache.get(1, ['id', 'name']);\\n\\n// To update a record just add it again\\nUser.cache.add(new User({ id: 1, name: 'Johnny' }));\\n\\n// Cache is per unique set of fields but a superset will update a subset\\nUser.cache.add(new User({ id: 1, name: 'Johnny Smith', email: 'johnny@test.com' }));\\nUser.cache.get(1, ['id', 'name']);\\n// { id: 1, name: 'Johnny Smith' }\\nUser.cache.get(1, ['id', 'name', 'email'])\\n// { id: 1, name: 'Johnny Smith', email: 'johnny@test.com' }\\n\\n// Delete a specific cache for a subset of fields\\nUser.cache.delete(1, ['id', 'name']);\\nUser.cache.get(1, ['id', 'name']);\\n// null\\nUser.cache.get(1, ['id', 'name', 'email'])\\n// { id: 1, name: 'Johnny Smith', email: 'johnny@test.com' }\\n\\n// Or all fields\\nUser.cache.delete(1);\\nUser.cache.get(1, ['id', 'name', 'email'])\\n// null\\n\\n// You can add multiple values at a time\\nUser.cache.addList([johnny, sam]);\\n\\n// You can listen to changes\\nUser.cache.addListener(2, ['id', 'name'], (previous, next) => console.log(previous, 'change to', next));\\nUser.cache.add(new User({ id: 2, name: 'Bob' }));\\n// null changed to User({ id: 2, name: 'Bob' })\\nUser.cache.add(new User({ id: 2, name: 'Bobby' }));\\n// User({ id: 2, name: 'Bob' }) changed to User({ id: 2, name: 'Bobby' })\\nUser.cache.delete(2)\\n// User({ id: 2, name: 'Bobby' }) changed to null\\n\\n// You can listen to multiple changes. If you use this and addList then you only get one\\n// call for each change that occurs within addList\\nUser.cache.addListenerList(\\n // Ids to listen for changes to\\n [3, 4],\\n // Only get updates for cached records with these field names\\n ['id', 'name'],\\n (previous, next) => console.log(previous, 'change to', next)\\n);\\nUser.cache.addList([new User({ id: 3, name: 'Jay' }), new User({ id: 4, name: 'Bee' })]);\\n// [null, null] changed to [new User({ id: 3, name: 'Jay' }), new User({ id: 4, name: 'Bee' })]\\nUser.cache.addList([new User({ id: 3, name: 'Jayz' }), new User({ id: 4, name: 'Beeb' })]);\\n// [new User({ id: 3, name: 'Jay' }), new User({ id: 4, name: 'Bee' })] changed to [new User({ id: 3, name: 'Jayz' }), new User({ id: 4, name: 'Beeb' })]\\nUser.cache.delete(3)\\n// [new User({ id: 3, name: 'Jayz' }), new User({ id: 4, name: 'Beeb' })] changed to [null, new User({ id: 4, name: 'Beeb' })]\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;","rawMDXOutput":"/* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\n\nexport const _frontmatter = {};\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\")\n  return <div {...props}/>\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = \"wrapper\"\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n    <p>{`The key to the cache is the primary key for the record and the field names\nset on it. For example if you have a record that accepts id, name and email\nyou could have a record cached for id, for name, for email or any\ncombination of the 3 fields. This is to handle the common case of fetching\npartial data from a backend.`}</p>\n    <p>{`The cache implementation will update any cache entries that are a subset\nof a new cache entry. eg. Caching a record with all the possible fields set\nwould result in all the existing partial field cache entries being updated\nto match the data on the full record for the fields it care about.`}</p>\n    <p>{`Usage:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`// Assume User is a ViewModel already defined\n\n// Add a record\nUser.cache.add(new User({ id: 1, name: 'John' }));\n\n// Retrieve a record\nconst record = User.cache.get(1, ['id', 'name']);\n\n// To update a record just add it again\nUser.cache.add(new User({ id: 1, name: 'Johnny' }));\n\n// Cache is per unique set of fields but a superset will update a subset\nUser.cache.add(new User({ id: 1, name: 'Johnny Smith', email: 'johnny@test.com' }));\nUser.cache.get(1, ['id', 'name']);\n// { id: 1, name: 'Johnny Smith' }\nUser.cache.get(1, ['id', 'name', 'email'])\n// { id: 1, name: 'Johnny Smith', email: 'johnny@test.com' }\n\n// Delete a specific cache for a subset of fields\nUser.cache.delete(1, ['id', 'name']);\nUser.cache.get(1, ['id', 'name']);\n// null\nUser.cache.get(1, ['id', 'name', 'email'])\n// { id: 1, name: 'Johnny Smith', email: 'johnny@test.com' }\n\n// Or all fields\nUser.cache.delete(1);\nUser.cache.get(1, ['id', 'name', 'email'])\n// null\n\n// You can add multiple values at a time\nUser.cache.addList([johnny, sam]);\n\n// You can listen to changes\nUser.cache.addListener(2, ['id', 'name'], (previous, next) => console.log(previous, 'change to', next));\nUser.cache.add(new User({ id: 2, name: 'Bob' }));\n// null changed to User({ id: 2, name: 'Bob' })\nUser.cache.add(new User({ id: 2, name: 'Bobby' }));\n// User({ id: 2, name: 'Bob' }) changed to User({ id: 2, name: 'Bobby' })\nUser.cache.delete(2)\n// User({ id: 2, name: 'Bobby' }) changed to null\n\n// You can listen to multiple changes. If you use this and addList then you only get one\n// call for each change that occurs within addList\nUser.cache.addListenerList(\n // Ids to listen for changes to\n [3, 4],\n // Only get updates for cached records with these field names\n ['id', 'name'],\n (previous, next) => console.log(previous, 'change to', next)\n);\nUser.cache.addList([new User({ id: 3, name: 'Jay' }), new User({ id: 4, name: 'Bee' })]);\n// [null, null] changed to [new User({ id: 3, name: 'Jay' }), new User({ id: 4, name: 'Bee' })]\nUser.cache.addList([new User({ id: 3, name: 'Jayz' }), new User({ id: 4, name: 'Beeb' })]);\n// [new User({ id: 3, name: 'Jay' }), new User({ id: 4, name: 'Bee' })] changed to [new User({ id: 3, name: 'Jayz' }), new User({ id: 4, name: 'Beeb' })]\nUser.cache.delete(3)\n// [new User({ id: 3, name: 'Jayz' }), new User({ id: 4, name: 'Beeb' })] changed to [null, new User({ id: 4, name: 'Beeb' })]\n`}</code></pre>\n\n    </MDXLayout>;\n}\n\n;\nMDXContent.isMDXComponent = true;"}}