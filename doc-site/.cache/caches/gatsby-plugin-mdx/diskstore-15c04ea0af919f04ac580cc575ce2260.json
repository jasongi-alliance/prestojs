{"expireTime":9007200833969725000,"key":"gatsby-plugin-mdx-entire-payload-8d3fcfb1f1f7376b0a696bdbd1d4f525-","val":{"mdast":{"type":"root","children":[{"type":"paragraph","children":[{"type":"text","value":"Accepts a ","position":{"start":{"line":1,"column":1,"offset":0},"end":{"line":1,"column":11,"offset":10},"indent":[]}},{"type":"inlineCode","value":"UrlPattern","position":{"start":{"line":1,"column":11,"offset":10},"end":{"line":1,"column":23,"offset":22},"indent":[]}},{"type":"text","value":" and optionally a ","position":{"start":{"line":1,"column":23,"offset":22},"end":{"line":1,"column":41,"offset":40},"indent":[]}},{"type":"inlineCode","value":"decodeBody","position":{"start":{"line":1,"column":41,"offset":40},"end":{"line":1,"column":53,"offset":52},"indent":[]}},{"type":"text","value":" function which decodes the ","position":{"start":{"line":1,"column":53,"offset":52},"end":{"line":1,"column":81,"offset":80},"indent":[]}},{"type":"inlineCode","value":"Response","position":{"start":{"line":1,"column":81,"offset":80},"end":{"line":1,"column":91,"offset":90},"indent":[]}},{"type":"text","value":" body as returned by\n","position":{"start":{"line":1,"column":91,"offset":90},"end":{"line":2,"column":1,"offset":111},"indent":[1]}},{"type":"inlineCode","value":"fetch","position":{"start":{"line":2,"column":1,"offset":111},"end":{"line":2,"column":8,"offset":118},"indent":[]}},{"type":"text","value":" and a ","position":{"start":{"line":2,"column":8,"offset":118},"end":{"line":2,"column":15,"offset":125},"indent":[]}},{"type":"inlineCode","value":"transformResponseBody","position":{"start":{"line":2,"column":15,"offset":125},"end":{"line":2,"column":38,"offset":148},"indent":[]}},{"type":"text","value":" function that can transform the decoded body. The default ","position":{"start":{"line":2,"column":38,"offset":148},"end":{"line":2,"column":97,"offset":207},"indent":[]}},{"type":"inlineCode","value":"decodeBody","position":{"start":{"line":2,"column":97,"offset":207},"end":{"line":2,"column":109,"offset":219},"indent":[]}},{"type":"text","value":" handles\ndecoding the data based on content type and is suitable for endpoints that return JSON or text with the appropriate\ncontent types. If you just wish to do something with the decoded data (eg. the JSON data) use ","position":{"start":{"line":2,"column":109,"offset":219},"end":{"line":4,"column":95,"offset":438},"indent":[1,1]}},{"type":"inlineCode","value":"transformResponseBody","position":{"start":{"line":4,"column":95,"offset":438},"end":{"line":4,"column":118,"offset":461},"indent":[]}},{"type":"text","value":".","position":{"start":{"line":4,"column":118,"offset":461},"end":{"line":4,"column":119,"offset":462},"indent":[]}}],"position":{"start":{"line":1,"column":1,"offset":0},"end":{"line":4,"column":119,"offset":462},"indent":[1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"In addition you can pass all options accepted by ","position":{"start":{"line":6,"column":1,"offset":464},"end":{"line":6,"column":50,"offset":513},"indent":[]}},{"type":"inlineCode","value":"fetch","position":{"start":{"line":6,"column":50,"offset":513},"end":{"line":6,"column":57,"offset":520},"indent":[]}},{"type":"text","value":" and these will be used as defaults to any call to ","position":{"start":{"line":6,"column":57,"offset":520},"end":{"line":6,"column":108,"offset":571},"indent":[]}},{"type":"inlineCode","value":"execute","position":{"start":{"line":6,"column":108,"offset":571},"end":{"line":6,"column":117,"offset":580},"indent":[]}},{"type":"text","value":"\nor ","position":{"start":{"line":6,"column":117,"offset":580},"end":{"line":7,"column":4,"offset":584},"indent":[1]}},{"type":"inlineCode","value":"prepare","position":{"start":{"line":7,"column":4,"offset":584},"end":{"line":7,"column":13,"offset":593},"indent":[]}},{"type":"text","value":".","position":{"start":{"line":7,"column":13,"offset":593},"end":{"line":7,"column":14,"offset":594},"indent":[]}}],"position":{"start":{"line":6,"column":1,"offset":464},"end":{"line":7,"column":14,"offset":594},"indent":[1]}},{"type":"paragraph","children":[{"type":"text","value":"Usage:","position":{"start":{"line":9,"column":1,"offset":596},"end":{"line":9,"column":7,"offset":602},"indent":[]}}],"position":{"start":{"line":9,"column":1,"offset":596},"end":{"line":9,"column":7,"offset":602},"indent":[]}},{"type":"code","lang":"js","meta":null,"value":"const userList = new Action(new UrlPattern('/api/users/'));\nconst users = await userList.execute();","position":{"start":{"line":11,"column":1,"offset":604},"end":{"line":14,"column":4,"offset":713},"indent":[1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"You can pass ","position":{"start":{"line":16,"column":1,"offset":715},"end":{"line":16,"column":14,"offset":728},"indent":[]}},{"type":"inlineCode","value":"urlArgs","position":{"start":{"line":16,"column":14,"offset":728},"end":{"line":16,"column":23,"offset":737},"indent":[]}},{"type":"text","value":" and ","position":{"start":{"line":16,"column":23,"offset":737},"end":{"line":16,"column":28,"offset":742},"indent":[]}},{"type":"inlineCode","value":"query","position":{"start":{"line":16,"column":28,"offset":742},"end":{"line":16,"column":35,"offset":749},"indent":[]}},{"type":"text","value":" to resolve the URL:","position":{"start":{"line":16,"column":35,"offset":749},"end":{"line":16,"column":55,"offset":769},"indent":[]}}],"position":{"start":{"line":16,"column":1,"offset":715},"end":{"line":16,"column":55,"offset":769},"indent":[]}},{"type":"code","lang":"js","meta":null,"value":"const userDetail = new Action(new UrlPattern('/api/user/:id/'));\n// Resolves to /api/user/1/?showAddresses=true\nconst user = await userDetail.execute({ urlArgs: { id: 1 }, query: 'showAddresses': true });","position":{"start":{"line":18,"column":1,"offset":771},"end":{"line":22,"column":4,"offset":985},"indent":[1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"You can also pass through any ","position":{"start":{"line":24,"column":1,"offset":987},"end":{"line":24,"column":31,"offset":1017},"indent":[]}},{"type":"inlineCode","value":"fetch","position":{"start":{"line":24,"column":31,"offset":1017},"end":{"line":24,"column":38,"offset":1024},"indent":[]}},{"type":"text","value":" options to both the constructor and calls to ","position":{"start":{"line":24,"column":38,"offset":1024},"end":{"line":24,"column":84,"offset":1070},"indent":[]}},{"type":"inlineCode","value":"execute","position":{"start":{"line":24,"column":84,"offset":1070},"end":{"line":24,"column":93,"offset":1079},"indent":[]}},{"type":"text","value":" and ","position":{"start":{"line":24,"column":93,"offset":1079},"end":{"line":24,"column":98,"offset":1084},"indent":[]}},{"type":"inlineCode","value":"prepare","position":{"start":{"line":24,"column":98,"offset":1084},"end":{"line":24,"column":107,"offset":1093},"indent":[]}}],"position":{"start":{"line":24,"column":1,"offset":987},"end":{"line":24,"column":107,"offset":1093},"indent":[]}},{"type":"code","lang":null,"meta":null,"value":"// Always pass through Content-Type header to all calls to userDetail\nconst userDetail = new Action(new UrlPattern('/api/user/:id/'), {\n    'Content-Type': 'application/json'\n});\n// Set other fetch options at execution time\nuserDetail.execute({ urlArgs: { id: 1 }, method: 'PATCH', body: JSON.stringify({ name: 'Dave' }) });","position":{"start":{"line":26,"column":1,"offset":1095},"end":{"line":33,"column":4,"offset":1427},"indent":[1,1,1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"Often you have some global options you want to apply everywhere. This can be set on ","position":{"start":{"line":35,"column":1,"offset":1429},"end":{"line":35,"column":85,"offset":1513},"indent":[]}},{"type":"inlineCode","value":"Endpoint","position":{"start":{"line":35,"column":85,"offset":1513},"end":{"line":35,"column":95,"offset":1523},"indent":[]}},{"type":"text","value":"\ndirectly:","position":{"start":{"line":35,"column":95,"offset":1523},"end":{"line":36,"column":10,"offset":1533},"indent":[1]}}],"position":{"start":{"line":35,"column":1,"offset":1429},"end":{"line":36,"column":10,"offset":1533},"indent":[1]}},{"type":"code","lang":"js","meta":null,"value":"// Set default options to pass through to the request init option of `fetch`\nEndpoint.defaultConfig.requestInit = {\n  headers: {\n    'X-CSRFToken': getCsrfToken(),\n  },\n};\n\n// All actions will now use the default headers specified\nuserDetail.execute({ urlArgs: { id: 1 } });","position":{"start":{"line":38,"column":1,"offset":1535},"end":{"line":48,"column":4,"offset":1819},"indent":[1,1,1,1,1,1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"You can also \"prepare\" an action for execution by calling the ","position":{"start":{"line":50,"column":1,"offset":1821},"end":{"line":50,"column":63,"offset":1883},"indent":[]}},{"type":"inlineCode","value":"prepare","position":{"start":{"line":50,"column":63,"offset":1883},"end":{"line":50,"column":72,"offset":1892},"indent":[]}},{"type":"text","value":" method. Each call to prepare will\nreturn the same object (ie. it passes strict equality checks) given the same parameters. This is useful when\nyou need to have a stable cache key for an action. For example you may have a React hook that executes\nyour action when things change:","position":{"start":{"line":50,"column":72,"offset":1892},"end":{"line":53,"column":32,"offset":2170},"indent":[1,1,1]}}],"position":{"start":{"line":50,"column":1,"offset":1821},"end":{"line":53,"column":32,"offset":2170},"indent":[1,1,1]}},{"type":"code","lang":"js","meta":null,"value":"import useSWR from 'swr';\n\n...\n\n// prepare the action and pass it to useSWR. useSWR will then call the second parameter (the \"fetcher\")\n// which executes the prepared action.\nconst { data } = useSWR([action.prepare()], (preparedAction) => preparedAction.execute());","position":{"start":{"line":55,"column":1,"offset":2172},"end":{"line":63,"column":4,"offset":2447},"indent":[1,1,1,1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"You can wrap this up in a custom hook to make usage more ergonomic:","position":{"start":{"line":65,"column":1,"offset":2449},"end":{"line":65,"column":68,"offset":2516},"indent":[]}}],"position":{"start":{"line":65,"column":1,"offset":2449},"end":{"line":65,"column":68,"offset":2516},"indent":[]}},{"type":"code","lang":"js","meta":null,"value":"import { useCallback } from 'react';\nimport useSWR from 'swr';\n\n/**\n* Wrapper around useSWR for use with `Endpoint`\n* @param action Endpoint to execute. Can be null if not yet ready to execute\n* @param args Any args to pass through to `prepare`\n* @return Object Same values as returned by useSWR with the addition of `execute` which\n* can be used to execute the action directly, optionally with new arguments.\n*\nexport default function useEndpoint(action, args) {\n  const preparedAction = action ? action.prepare(args) : null;\n  const execute = useCallback(init => preparedAction.execute(init), [preparedAction]);\n  return {\n    execute,\n    ...useSWR(preparedAction && [preparedAction], act => act.execute()),\n  };\n}","position":{"start":{"line":67,"column":1,"offset":2518},"end":{"line":86,"column":4,"offset":3245},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"export","value":"export const _frontmatter = {}","position":{"start":{"line":89,"column":1,"offset":3248},"end":{"line":89,"column":31,"offset":3278},"indent":[]}}],"position":{"start":{"line":1,"column":1,"offset":0},"end":{"line":89,"column":31,"offset":3278}}},"scopeImports":["import React from 'react'"],"scopeIdentifiers":["React"],"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Accepts a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UrlPattern\"), \" and optionally a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"decodeBody\"), \" function which decodes the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Response\"), \" body as returned by\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"fetch\"), \" and a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"transformResponseBody\"), \" function that can transform the decoded body. The default \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"decodeBody\"), \" handles\\ndecoding the data based on content type and is suitable for endpoints that return JSON or text with the appropriate\\ncontent types. If you just wish to do something with the decoded data (eg. the JSON data) use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"transformResponseBody\"), \".\"), mdx(\"p\", null, \"In addition you can pass all options accepted by \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"fetch\"), \" and these will be used as defaults to any call to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"execute\"), \"\\nor \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"prepare\"), \".\"), mdx(\"p\", null, \"Usage:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const userList = new Action(new UrlPattern('/api/users/'));\\nconst users = await userList.execute();\\n\")), mdx(\"p\", null, \"You can pass \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"urlArgs\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"query\"), \" to resolve the URL:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const userDetail = new Action(new UrlPattern('/api/user/:id/'));\\n// Resolves to /api/user/1/?showAddresses=true\\nconst user = await userDetail.execute({ urlArgs: { id: 1 }, query: 'showAddresses': true });\\n\")), mdx(\"p\", null, \"You can also pass through any \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"fetch\"), \" options to both the constructor and calls to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"execute\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"prepare\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"// Always pass through Content-Type header to all calls to userDetail\\nconst userDetail = new Action(new UrlPattern('/api/user/:id/'), {\\n    'Content-Type': 'application/json'\\n});\\n// Set other fetch options at execution time\\nuserDetail.execute({ urlArgs: { id: 1 }, method: 'PATCH', body: JSON.stringify({ name: 'Dave' }) });\\n\")), mdx(\"p\", null, \"Often you have some global options you want to apply everywhere. This can be set on \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Endpoint\"), \"\\ndirectly:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"// Set default options to pass through to the request init option of `fetch`\\nEndpoint.defaultConfig.requestInit = {\\n  headers: {\\n    'X-CSRFToken': getCsrfToken(),\\n  },\\n};\\n\\n// All actions will now use the default headers specified\\nuserDetail.execute({ urlArgs: { id: 1 } });\\n\")), mdx(\"p\", null, \"You can also \\\"prepare\\\" an action for execution by calling the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"prepare\"), \" method. Each call to prepare will\\nreturn the same object (ie. it passes strict equality checks) given the same parameters. This is useful when\\nyou need to have a stable cache key for an action. For example you may have a React hook that executes\\nyour action when things change:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"import useSWR from 'swr';\\n\\n...\\n\\n// prepare the action and pass it to useSWR. useSWR will then call the second parameter (the \\\"fetcher\\\")\\n// which executes the prepared action.\\nconst { data } = useSWR([action.prepare()], (preparedAction) => preparedAction.execute());\\n\")), mdx(\"p\", null, \"You can wrap this up in a custom hook to make usage more ergonomic:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"import { useCallback } from 'react';\\nimport useSWR from 'swr';\\n\\n/**\\n* Wrapper around useSWR for use with `Endpoint`\\n* @param action Endpoint to execute. Can be null if not yet ready to execute\\n* @param args Any args to pass through to `prepare`\\n* @return Object Same values as returned by useSWR with the addition of `execute` which\\n* can be used to execute the action directly, optionally with new arguments.\\n*\\nexport default function useEndpoint(action, args) {\\n  const preparedAction = action ? action.prepare(args) : null;\\n  const execute = useCallback(init => preparedAction.execute(init), [preparedAction]);\\n  return {\\n    execute,\\n    ...useSWR(preparedAction && [preparedAction], act => act.execute()),\\n  };\\n}\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;","rawMDXOutput":"/* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\n\nexport const _frontmatter = {};\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\")\n  return <div {...props}/>\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = \"wrapper\"\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n    <p>{`Accepts a `}<inlineCode parentName=\"p\">{`UrlPattern`}</inlineCode>{` and optionally a `}<inlineCode parentName=\"p\">{`decodeBody`}</inlineCode>{` function which decodes the `}<inlineCode parentName=\"p\">{`Response`}</inlineCode>{` body as returned by\n`}<inlineCode parentName=\"p\">{`fetch`}</inlineCode>{` and a `}<inlineCode parentName=\"p\">{`transformResponseBody`}</inlineCode>{` function that can transform the decoded body. The default `}<inlineCode parentName=\"p\">{`decodeBody`}</inlineCode>{` handles\ndecoding the data based on content type and is suitable for endpoints that return JSON or text with the appropriate\ncontent types. If you just wish to do something with the decoded data (eg. the JSON data) use `}<inlineCode parentName=\"p\">{`transformResponseBody`}</inlineCode>{`.`}</p>\n    <p>{`In addition you can pass all options accepted by `}<inlineCode parentName=\"p\">{`fetch`}</inlineCode>{` and these will be used as defaults to any call to `}<inlineCode parentName=\"p\">{`execute`}</inlineCode>{`\nor `}<inlineCode parentName=\"p\">{`prepare`}</inlineCode>{`.`}</p>\n    <p>{`Usage:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`const userList = new Action(new UrlPattern('/api/users/'));\nconst users = await userList.execute();\n`}</code></pre>\n    <p>{`You can pass `}<inlineCode parentName=\"p\">{`urlArgs`}</inlineCode>{` and `}<inlineCode parentName=\"p\">{`query`}</inlineCode>{` to resolve the URL:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`const userDetail = new Action(new UrlPattern('/api/user/:id/'));\n// Resolves to /api/user/1/?showAddresses=true\nconst user = await userDetail.execute({ urlArgs: { id: 1 }, query: 'showAddresses': true });\n`}</code></pre>\n    <p>{`You can also pass through any `}<inlineCode parentName=\"p\">{`fetch`}</inlineCode>{` options to both the constructor and calls to `}<inlineCode parentName=\"p\">{`execute`}</inlineCode>{` and `}<inlineCode parentName=\"p\">{`prepare`}</inlineCode></p>\n    <pre><code parentName=\"pre\" {...{}}>{`// Always pass through Content-Type header to all calls to userDetail\nconst userDetail = new Action(new UrlPattern('/api/user/:id/'), {\n    'Content-Type': 'application/json'\n});\n// Set other fetch options at execution time\nuserDetail.execute({ urlArgs: { id: 1 }, method: 'PATCH', body: JSON.stringify({ name: 'Dave' }) });\n`}</code></pre>\n    <p>{`Often you have some global options you want to apply everywhere. This can be set on `}<inlineCode parentName=\"p\">{`Endpoint`}</inlineCode>{`\ndirectly:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`// Set default options to pass through to the request init option of \\`fetch\\`\nEndpoint.defaultConfig.requestInit = {\n  headers: {\n    'X-CSRFToken': getCsrfToken(),\n  },\n};\n\n// All actions will now use the default headers specified\nuserDetail.execute({ urlArgs: { id: 1 } });\n`}</code></pre>\n    <p>{`You can also \"prepare\" an action for execution by calling the `}<inlineCode parentName=\"p\">{`prepare`}</inlineCode>{` method. Each call to prepare will\nreturn the same object (ie. it passes strict equality checks) given the same parameters. This is useful when\nyou need to have a stable cache key for an action. For example you may have a React hook that executes\nyour action when things change:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`import useSWR from 'swr';\n\n...\n\n// prepare the action and pass it to useSWR. useSWR will then call the second parameter (the \"fetcher\")\n// which executes the prepared action.\nconst { data } = useSWR([action.prepare()], (preparedAction) => preparedAction.execute());\n`}</code></pre>\n    <p>{`You can wrap this up in a custom hook to make usage more ergonomic:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`import { useCallback } from 'react';\nimport useSWR from 'swr';\n\n/**\n* Wrapper around useSWR for use with \\`Endpoint\\`\n* @param action Endpoint to execute. Can be null if not yet ready to execute\n* @param args Any args to pass through to \\`prepare\\`\n* @return Object Same values as returned by useSWR with the addition of \\`execute\\` which\n* can be used to execute the action directly, optionally with new arguments.\n*\nexport default function useEndpoint(action, args) {\n  const preparedAction = action ? action.prepare(args) : null;\n  const execute = useCallback(init => preparedAction.execute(init), [preparedAction]);\n  return {\n    execute,\n    ...useSWR(preparedAction && [preparedAction], act => act.execute()),\n  };\n}\n`}</code></pre>\n\n    </MDXLayout>;\n}\n\n;\nMDXContent.isMDXComponent = true;"}}